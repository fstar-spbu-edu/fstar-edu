module Substraction

open IntLib
open Limb
open FStar.Seq
open Eval
open Axiomatic
open FStar.ST
open FStar.Heap
open Bigint

(* 
   Auxiliary substraction function. 
   Takes two input arrays, the current index for the computation and the temporary result 
 *)

(* Auxiliary substraction function putting the result in the first operand *)
(* Code, not tailrecursive, proof without witness *)
val substraction:
  a:bigint -> a_idx:nat ->  b:bigint -> b_idx:nat -> len:nat ->
  ST unit
    (requires (fun h -> 
      (inHeap h a)
      /\ (inHeap h b)
      /\ (Bigint63.data a <> Bigint63.data b)
      /\ (getLength h a >= a_idx + len)
      /\ (getLength h b >= b_idx + len)
      /\ (maxSize h a <= wordSize a - 2)
      /\ (maxSize h b <= wordSize a - 2)
    ))
    (ensures (fun h0 u h1 -> 
	      (inHeap h1 a)
	      /\ (inHeap h1 b)
	      /\ (inHeap h0 a)
	      /\ (inHeap h0 b)
	      /\ (Bigint63.data a <> Bigint63.data b)

	      /\ (modifies !{Bigint63.data a} h0 h1)
		 
	      /\ (maxSize h0 a <= wordSize a - 2)
	      /\ (maxSize h0 b <= wordSize a - 2)
	      /\ (getLength h1 a = getLength h0 a)
	      /\ (getLength h1 b  = getLength h0 b)
	      /\ (getLength h0 a >= a_idx + len)
	      /\ (getLength h0 b >= b_idx + len)

	      /\ (forall (i:nat).
		  i < len ==> 
		    getValue h1 a (i+a_idx) = getValue h0 a (i+a_idx) - getValue h0 b (i+b_idx)) 
		 
	      /\ (forall (i:nat).
		  (i < getLength h1 a /\ (i < a_idx \/ i >= a_idx + len)) ==> 
		    getValue h1 a i = getValue h0 a i)
		 
	      /\ (forall (i:nat).
		  i < len ==> 
		    getSize h1 a (i+a_idx) = max (getSize h0 a (i+a_idx)) (getSize h0 b (i+b_idx)) + 1)
		 
	      /\ (forall (i:nat).
		  (i < getLength h1 a /\ (i < a_idx \/ i >= a_idx + len)) ==> 
		    getSize h1 a i = getSize h0 a i)
 
))
let rec substraction a a_idx b b_idx len =
  match len with
  | 0 -> ()
  |  _ -> 
      let h0 = erase (ST.get()) in
      substraction a a_idx b b_idx (len-1);
      let h1 =
	erase (ST.get ()) in
      let ai = Bigint.get a (a_idx+len-1) in
      let size_ai =
	erase (getSize h1 a (a_idx+len-1)) in
      let bi = Bigint.get b (b_idx+len-1) in
      let size_bi = 
	erase (getSize h1 b (b_idx+len-1)) in
      let v = Limb.sub size_ai ai size_bi bi in
      erase (
	  order_n_bits v (max size_ai size_bi + 1) (wordSize a - 1));
      let (t:tint (wordSize a)) = mk_tint a (erase (max size_ai size_bi + 1))  v in
      let h1 = erase (ST.get()) in
      updateBigint a (a_idx+len-1) t


(* Code *)
(* Tail recursive version of the substraction *)
val substraction_tr:
  ghost_a:seq (tint ocaml63) -> a:bigint -> a_idx:nat ->  b:bigint -> b_idx:nat -> len:nat -> ctr:nat ->
  ST unit
    (requires (fun h -> 
	       (inHeap h a) 
	       /\ (inHeap h b)
	       /\ (Bigint63.data a <> Bigint63.data b)
	       /\ (getLength h a >= a_idx + len) 
	       /\ (getLength h b >= b_idx + len)
	       /\ (Seq.length ghost_a = getLength h a)
	       /\ (ctr <= len)
	       /\ (forall (i:nat). i < Seq.length ghost_a
		   ==> dfst (Seq.index ghost_a i) <= wordSize a - 2)
	       /\ (maxSize h b <= wordSize a - 2)
	       /\ (forall (i:nat). i < ctr
		   ==> (
		      (getValue h a (a_idx+i) = dsnd (Seq.index ghost_a (a_idx+i)) - getValue h b (b_idx+i))
		      /\ (getSize h a (a_idx+i) = max (dfst (Seq.index ghost_a (a_idx+i))) (getSize h b (b_idx+i)) + 1)))
	       /\ (forall (i:nat). ( i < getLength h a /\ (i < a_idx \/ i >= a_idx + ctr))
		   ==> (getValue h a i = dsnd (Seq.index ghost_a i) /\ getSize h a i = dfst (Seq.index ghost_a i)))
    ))
    (ensures (fun h0 u h1 -> 
	      (inHeap h1 a) 
	      /\ (inHeap h1 b) 
	      /\ (inHeap h0 a) 
	      /\ (inHeap h0 b)
	      /\ (Bigint63.data a <> Bigint63.data b)
		 
	      /\ (modifies !{Bigint63.data a} h0 h1)
		 
	      /\ (forall (i:nat). i < Seq.length ghost_a
		  ==> dfst (Seq.index ghost_a i) <= wordSize a - 2)
	      /\ (maxSize h0 b <= wordSize a - 2)
	      /\ (getLength h1 a = getLength h0 a)
	      /\ (getLength h1 b  = getLength h0 b)
	      /\ (getLength h0 a >= a_idx + len)
	      /\ (getLength h0 b >= b_idx + len)
	      /\ (ctr <= len)
	      /\ (Seq.length ghost_a = getLength h0 a)
		 
	      /\ (forall (i:nat). i < len 
		  ==> ((getValue h1 a (i+a_idx) = dsnd (Seq.index ghost_a (a_idx+i)) - getValue h0 b (i+b_idx)) 
		       /\ (getSize h1 a (i+a_idx) = max (dfst (Seq.index ghost_a (a_idx+i))) (getSize h0 b (i+b_idx)) + 1)))
		 
	      /\ (forall (i:nat). (i < getLength h1 a /\ (i < a_idx \/ i >= a_idx + len)) 
		  ==> (getValue h1 a i = dsnd (Seq.index ghost_a i) /\ getSize h1 a i = dfst (Seq.index ghost_a i)))
   
))

let rec substraction_tr ghost_a a a_idx b b_idx len ctr =
  match len - ctr with
  | 0 -> ()
  | _ -> 
      let i = ctr in
      let h1 =
	erase (ST.get ()) in
      let ai = Bigint.get a (a_idx+i) in
      let size_ai =
	erase (getSize h1 a (a_idx+i)) in
      let bi = Bigint.get b (b_idx+i) in
      let size_bi = 
	erase (getSize h1 b (b_idx+i)) in
      let v = Limb.sub size_ai ai size_bi bi in
      let (t:tint (wordSize a)) = mk_tint a (erase (max size_ai size_bi + 1))  v in
      updateBigint a (a_idx+i) t;
      substraction_tr ghost_a a a_idx b b_idx len (ctr+1);
      ()


val substraction_lemma_aux:
  h0:heap ->
  h1:heap ->
  a:bigint{ (inHeap h0 a) 
	    /\ (inHeap h1 a)
	    /\ (maxSize h0 a <= wordSize a - 2) } -> 
  b:bigint{ (inHeap h0 b)
	    /\ (maxSize h0 b <= wordSize a - 2)
	    /\ (Bigint63.t b = Bigint63.t a) } ->
  len:pos{ (len <= getLength h0 a)
	   /\ (len <= getLength h0 b)
	   /\ (len <= getLength h1 a)
	   /\ (forall (i:nat). i < len 
	       ==> getValue h1 a i = getValue h0 a i - getValue h0 b i) } ->
  Lemma
    (requires ( (eval h0 a (len-1) - eval h0 b (len-1) = eval h1 a (len-1))
		/\ (getValue h1 a (len-1) = getValue h0 a (len-1) - getValue h0 b (len-1)) ) )
    (ensures (eval h0 a len - eval h0 b len = eval h1 a len))
let substraction_lemma_aux h0 h1 a b len =
  erase (
      distributivity_sub_right (pow2 (bitweight (Bigint63.t a) (len-1))) (getValue h0 a (len-1))  (getValue h0 b (len-1))
    )

val substraction_lemma:
  h0:heap ->
  h1:heap ->
  a:bigint{ (inHeap h0 a) 
	    /\ (inHeap h1 a)
	    /\ (maxSize h0 a <= wordSize a - 2) } -> 
  b:bigint{ (inHeap h0 b)
	    /\ (maxSize h0 b <= wordSize a - 2)
	    /\ (Bigint63.t b = Bigint63.t a) } ->
  len:nat{ (len <= getLength h0 a)
	   /\ (len <= getLength h0 b)
	   /\ (len <= getLength h1 a)
	   /\ (forall (i:nat). i < len 
	       ==> getValue h1 a i = getValue h0 a i - getValue h0 b i) } ->
  Lemma
    (requires (True))
    (ensures ( eval h0 a len - eval h0 b len = eval h1 a len ))
let rec substraction_lemma h0 h1 a b len =
  erase (
      match len with
      | 0 -> ()
      | _ -> substraction_lemma h0 h1 a b (len-1);
	     substraction_lemma_aux h0 h1 a b len
    )

val substraction_max_value_lemma:
  h0:heap -> 
  h1:heap -> 
  a:bigint{ (inHeap h0 a)
	    /\ (maxSize h0 a <= wordSize a - 2) } -> 
  b:bigint{ (inHeap h0 b)
	    /\ (maxSize h0 b <= wordSize a - 2)
	    /\ (getLength h0 a = getLength h0 b) } ->
  c:bigint{ (inHeap h1 c)
	    /\ (getLength h1 c = getLength h0 a)
	    /\ (forall (i:nat). i < getLength h1 c 
		==> getValue h1 c i = getValue h0 a i - getValue h0 b i) } ->
  Lemma
    (requires (True))
    (ensures (maxValue h1 c <= maxValue h0 a + maxValue h0 b))
let substraction_max_value_lemma h0 h1 a b c = ()
  
val substraction_max_size_lemma:
  h0:heap -> 
  h1:heap -> 
  a:bigint{ (inHeap h0 a) } -> 
  b:bigint{ (inHeap h0 b)
	    /\ (getLength h0 a = getLength h0 b) } ->
  c:bigint{ (inHeap h1 c)
	    /\ (getLength h1 c = getLength h0 a)
	    /\ (forall (i:nat). i < getLength h1 c 
		==> getSize h1 c i = max (getSize h0 a i) (getSize h0 b i) + 1) } ->
  Lemma
    (requires (True))
    (ensures (maxSize h1 c <= max (maxSize h0 a) (maxSize h0 b) + 1))
let substraction_max_size_lemma h0 h1 a b c = ()

val max_value_lemma: h:heap -> a:bigint{ inHeap h a } -> m:nat ->
		     Lemma 
		       (requires (forall (n:nat). n < getLength h a ==> abs (getValue h a n) <= m))
		       (ensures (maxValue h a <= m))
let max_value_lemma h a m = ()

val abs_lemma: unit -> Lemma (ensures (forall a b. abs (a + b) <= abs a + abs b))
let abs_lemma () = () 

val substraction_max_value_lemma_extended:
  h0:heap -> 
  h1:heap -> 
  a:bigint{ (inHeap h0 a) } -> 
  b:bigint{ (inHeap h0 b) } ->
  c:bigint{ (inHeap h1 c)
	    /\ (getLength h0 a = getLength h1 c) } ->
  idx:nat ->
  len:nat{ len + idx <= getLength h0 a /\ len <= getLength h0 b } ->
  Lemma
    (requires ((forall (i:nat). i < len 
		==> getValue h1 c (i+idx) = getValue h0 a (i+idx) - getValue h0 b i)
	       /\ (forall (i:nat). ( i < getLength h1 c /\ (i < idx \/ i >= idx + len))
		   ==> getValue h1 c i = getValue h0 a i)))
    (ensures (maxValue h1 c <= maxValue h0 a + maxValue h0 b))
let substraction_max_value_lemma_extended h0 h1 a b c idx len = 
  erase (
    cut ( forall (i:nat). (i < getLength h1 c /\ (i < idx \/ i >= idx + len))
	  ==> (getValue h1 c i = getValue h0 a i /\ abs (getValue h1 c i) <= maxValue h0 a + maxValue h0 b));
    cut ( forall (i:nat). (i < getLength h1 c /\ (i < idx \/ i >= idx + len)) 
  	  ==> abs (getValue h1 c i) <= maxValue h0 a + maxValue h0 b);
    abs_lemma ();
    cut ( forall (i:nat). (i < idx + len /\ i >= idx)
	  ==> ((getValue h1 c i = getValue h0 a i - getValue h0 b (i-idx)) 
	       /\ (abs (getValue h1 c i) <= abs (getValue h0 a i) + abs (getValue h0 b (i-idx)))) );
    cut ( forall (i:nat). (i < idx + len /\ i >= idx)
	  ==> ( abs (getValue h0 a i) <= maxValue h0 a /\ abs (getValue h0 b (i-idx)) <= maxValue h0 b));
    cut ( forall (i:nat). (i >= idx /\ i < idx + len)
	  ==> abs (getValue h1 c i) <= maxValue h0 a + maxValue h0 b);
    cut ( forall (i:nat). i < getLength h1 c 
	  ==> abs (getValue h1 c i) <= maxValue h0 a + maxValue h0 b);
    max_value_lemma h1 c (maxValue h0 a + maxValue h0 b);
    ()
  )
    
val substraction_max_size_lemma_extended:
  h0:heap -> 
  h1:heap -> 
  a:bigint{ (inHeap h0 a) } -> 
  b:bigint{ (inHeap h0 b) } ->
  c:bigint{ (inHeap h1 c)
	    /\ (getLength h0 a = getLength h1 c) } ->
  idx:nat ->
  len:nat{ len + idx <= getLength h0 a /\ len <= getLength h0 b } ->
  Lemma
    (requires ((forall (i:nat). i < len 
		==> getSize h1 c (i+idx) = max (getSize h0 a (i+idx)) (getSize h0 b i) + 1)
	       /\ (forall (i:nat). ( i < getLength h1 c /\ (i < idx \/ i >= idx + len))
		   ==> getSize h1 c i = getSize h0 a i)))
    (ensures (maxSize h1 c <= max (maxSize h0 a) (maxSize h0 b) + 1))
let substraction_max_size_lemma_extended h0 h1 a b c idx len = 
  cut ( forall (i:nat). (i < getLength h1 c /\ (i < idx \/ i >= idx + len))
	==> (getSize h1 c i = getSize h0 a i /\ getSize h1 c i <= max (maxSize h0 a) (maxSize h0 b) + 1) );
  cut ( forall (i:nat). (i < getLength h1 c /\ (i < idx \/ i >= idx + len)) 
  	==> getSize h1 c i <= max (maxSize h0 a) (maxSize h0 b) + 1 );
  
  cut ( forall (i:nat). (i < idx + len /\ i >= idx)
	==> ((getSize h1 c i = max (getSize h0 a i) (getSize h0 b (i-idx)) + 1) 
	     /\ (getSize h1 c i <= max (getSize h0 a i) (getSize h0 b (i-idx)) + 1 )) );
  cut ( forall (i:nat). (i < idx + len /\ i >= idx)
	==> ( getSize h0 a i <= maxSize h0 a /\ getSize h0 b (i-idx) <= maxSize h0 b));
  cut ( forall (i:nat). (i >= idx /\ i < idx + len)
	==> getSize h1 c i <= max (maxSize h0 a) (maxSize h0 b) + 1 );
  cut ( forall (i:nat). i < getLength h1 c 
	==> getSize h1 c i <= max (maxSize h0 a) (maxSize h0 b) + 1 );
  ()


val substraction_with_lemma:
  a:bigint -> b:bigint -> len:nat ->
  ST unit
    (requires (fun h -> 
      (inHeap h a)
      /\ (inHeap h b)
      /\ (Bigint63.data a <> Bigint63.data b)
      /\ (Bigint63.t a = Bigint63.t b)
      /\ (Seq.length (sel h (Bigint63.data a)) >= len)
      /\ (Seq.length (sel h (Bigint63.data b)) >= len)
      /\ (maxSize h a <= wordSize a - 2)
      /\ (maxSize h b <= wordSize a - 2)
    ))
    (ensures (fun h0 u h1 -> 
      (inHeap h1 a)
      /\ (inHeap h1 b)
      /\ (inHeap h0 a)
      /\ (inHeap h0 b)
      /\ (modifies !{Bigint63.data a} h0 h1)
      /\ (maxSize h0 a <= wordSize a - 2)
      /\ (maxSize h0 b <= wordSize a - 2)
      /\ (Bigint63.t a = Bigint63.t b)
      /\ (Bigint63.data a <> Bigint63.data b)
      /\ (Seq.length (sel h1 (Bigint63.data a)) = Seq.length (sel h0 (Bigint63.data a)))
      /\ (Seq.length (sel h1 (Bigint63.data b)) = Seq.length (sel h0 (Bigint63.data b)))
      /\ (Seq.length (sel h1 (Bigint63.data a)) >= len)
      /\ (Seq.length (sel h1 (Bigint63.data b)) >= len)
      /\ (eval h1 a len = eval h0 a len - eval h0 b len)
    ))
let substraction_with_lemma a b len =
  let h0 =
    erase (ST.get()) in
  substraction_tr (erase (Array.to_seq (Bigint63.data a))) a 0 b 0 len 0;
  erase (
      let h1 = ST.get() in      
      substraction_lemma h0 h1 a b len;
      substraction_max_value_lemma_extended h0 h1 a b a 0 len;
      substraction_max_size_lemma_extended h0 h1 a b a 0 len
    )
